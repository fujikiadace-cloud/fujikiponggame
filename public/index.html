<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>ふじきたきゅうげーむ（通信）</title>
  <style>
    html,body{margin:0;height:100%;background:#000;color:#e8eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;}
    #wrap{height:100%;display:flex;align-items:center;justify-content:center;overflow:hidden;}
    canvas{touch-action:none;display:block;background:#0b0f14;}
    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(1200px 800px at 50% 30%, rgba(20,36,58,.96) 0%, rgba(11,15,20,.96) 62%, rgba(7,10,15,.96) 100%);
      padding:18px;}
    .panel{width:min(860px,100%);background:rgba(0,0,0,.42);border:1px solid rgba(255,255,255,.14);border-radius:16px;
      padding:14px 14px 16px;box-shadow:0 12px 40px rgba(0,0,0,.45);backdrop-filter:blur(6px);}
    .title{font-weight:900;letter-spacing:.6px;font-size:18px;}
    .sub{opacity:.86;font-size:12px;line-height:1.45;margin-top:6px;}
    .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap;margin-top:12px;}
    .picker{display:flex;gap:10px;align-items:center;}
    .label{font-weight:900;font-size:12px;opacity:.9;}
    .thumb{width:54px;height:54px;border-radius:14px;overflow:hidden;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.16);
      display:flex;align-items:center;justify-content:center;}
    .thumb img{width:100%;height:100%;object-fit:cover;}
    input{width:140px;border-radius:14px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.08);color:#e8eef7;
      padding:10px 12px;font-weight:900;letter-spacing:.8px;text-transform:uppercase;}
    button{appearance:none;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.08);color:#e8eef7;border-radius:14px;
      padding:10px 12px;font-weight:900;}
    button.primary{background:rgba(124,255,178,.18);border-color:rgba(124,255,178,.30);}
    button.danger{background:rgba(255,107,107,.14);border-color:rgba(255,107,107,.26);}
    button:active{transform:translateY(1px);}
    .small{font-size:12px;padding:8px 10px;border-radius:12px;}
    .hidden{display:none!important;}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.12);font-weight:900;font-size:12px;}
  </style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>

<div id="lobby" class="overlay">
  <div class="panel">
    <div class="title">ふじきたきゅうげーむ（通信）</div>
    <div class="sub">
      ・スマホ縦画面専用（上下で対戦）<br/>
      ・自分の半分だけ操作（上/下）<br/>
      ・必殺：ゲージMAXで <b>ダブルタップ</b> → 次の返球が<b>加速＋カーブ</b>
    </div>

    <div class="row">
      <div class="badge" id="connBadge">未接続</div>
      <div class="sub" id="wsInfo"></div>
    </div>

    <div class="row">
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button id="createRoom" class="primary">部屋を作る</button>
        <span class="label">部屋コード</span>
        <input id="roomCode" placeholder="ABCD" maxlength="8"/>
        <button id="joinRoom">入る</button>
      </div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button id="startBtn" class="primary" disabled>ゲーム開始</button>
        <button id="leaveBtn" class="danger" disabled>退出</button>
      </div>
    </div>

    <div class="row">
      <div class="picker">
        <span class="label">自分のキャラ</span>
        <button class="small" id="mePrev">◀</button>
        <div class="thumb"><img id="meImg" alt="me"/></div>
        <button class="small" id="meNext">▶</button>
      </div>
      <div class="picker">
        <span class="label">相手のキャラ</span>
        <div class="thumb"><img id="opImg" alt="op"/></div>
      </div>
      <div class="sub" id="roleText">役割：-</div>
    </div>

    <div class="sub" id="msg" style="margin-top:12px;">接続中…（しばらく待ってください）</div>
  </div>
</div>

<script>
(()=> {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const el = {
    lobby: document.getElementById("lobby"),
    connBadge: document.getElementById("connBadge"),
    wsInfo: document.getElementById("wsInfo"),
    createRoom: document.getElementById("createRoom"),
    roomCode: document.getElementById("roomCode"),
    joinRoom: document.getElementById("joinRoom"),
    startBtn: document.getElementById("startBtn"),
    leaveBtn: document.getElementById("leaveBtn"),
    mePrev: document.getElementById("mePrev"),
    meNext: document.getElementById("meNext"),
    meImg: document.getElementById("meImg"),
    opImg: document.getElementById("opImg"),
    roleText: document.getElementById("roleText"),
    msg: document.getElementById("msg"),
  };

  const spriteFiles = ["assets/char1.png","assets/char2.png","assets/char3.png"];
  const sprites = spriteFiles.map(src => { const img = new Image(); img.src = src; return img; });
  const wrapIdx = (i) => (i % sprites.length + sprites.length) % sprites.length;

  let myChar = 0, opChar = 1;
  function updateThumbs(){ el.meImg.src = spriteFiles[myChar]; el.opImg.src = spriteFiles[opChar]; }
  updateThumbs();

  function send(obj){ if (ws && ws.readyState===1) ws.send(JSON.stringify(obj)); }

  el.mePrev.onclick = ()=>{ myChar=wrapIdx(myChar-1); updateThumbs(); send({t:"char", c: myChar}); };
  el.meNext.onclick = ()=>{ myChar=wrapIdx(myChar+1); updateThumbs(); send({t:"char", c: myChar}); };

  const state = { vw:0,vh:0,w:420,h:780, role:null, room:null, connected:false, inRoom:false, started:false };

  function layout(){
    const vw = window.innerWidth, vh = window.innerHeight;
    state.vw=vw; state.vh=vh;
    const targetAspect = 9/16;
    let cw = vw, ch = vh;
    if (cw/ch > targetAspect) cw = ch*targetAspect; else ch = cw/targetAspect;
    canvas.style.width = `${cw}px`; canvas.style.height = `${ch}px`;
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    canvas.width = Math.floor(cw*dpr); canvas.height = Math.floor(ch*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    state.w = cw; state.h = ch;
  }
  window.addEventListener("resize", layout);
  window.addEventListener("orientationchange", layout);
  requestAnimationFrame(layout);

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  const WS_URL = (() => {
    const proto = location.protocol === "https:" ? "wss:" : "ws:";
    return `${proto}//${location.host}/ws`;
  })();
  el.wsInfo.textContent = `接続先：${WS_URL}`;

  function badge(text, ok=false){
    el.connBadge.textContent = text;
    el.connBadge.style.background = ok ? "rgba(124,255,178,.12)" : "rgba(255,255,255,.07)";
    el.connBadge.style.borderColor = ok ? "rgba(124,255,178,.24)" : "rgba(255,255,255,.12)";
  }

  let ws=null;
  function connect(){
    badge("接続中…");
    ws = new WebSocket(WS_URL);
    ws.onopen = ()=>{
      state.connected=true;
      badge("接続OK", false);
      el.msg.textContent="接続OK。部屋を作る or 入ってください。";
      send({t:"hello", c: myChar});
    };
    ws.onclose = ()=>{
      state.connected=false; state.inRoom=false; state.role=null;
      badge("未接続");
      el.startBtn.disabled=true; el.leaveBtn.disabled=true;
      el.msg.textContent="切断されました。ページを再読み込みしてください。";
    };
    ws.onerror = ()=>{ el.msg.textContent="接続エラー。サーバーが起動しているか確認してください。"; };
    ws.onmessage = (ev)=>{
      let msg=null; try{ msg=JSON.parse(ev.data);}catch{return;}
      onMsg(msg);
    };
  }

  el.createRoom.onclick = ()=> send({t:"create", c: myChar});
  el.joinRoom.onclick = ()=>{
    const code=(el.roomCode.value||"").trim().toUpperCase();
    if(!code){ el.msg.textContent="部屋コードを入力してください"; return; }
    send({t:"join", room: code, c: myChar});
  };
  el.leaveBtn.onclick = ()=>{
    if(!state.inRoom) return;
    send({t:"leave"});
    state.inRoom=false; state.role=null; state.room=null;
    el.roleText.textContent="役割：-";
    el.msg.textContent="退出しました。部屋を作る or 入ってください。";
    el.startBtn.disabled=true; el.leaveBtn.disabled=true;
  };
  el.startBtn.onclick = ()=> send({t:"start"});

  const game = { mode:"ready", scoreT:0, scoreB:0, paddleT:0.5, paddleB:0.5, ballX:0.5, ballY:0.5, ballR:0.012,
    gaugeT:0, gaugeB:0, armedT:false, armedB:false, winner:null };

  function onMsg(m){
    if (m.t==="room"){
      state.inRoom=true; state.room=m.room; state.role=m.role;
      el.roomCode.value=m.room;
      el.roleText.textContent = `役割：${m.role==="T"?"上プレイヤー":"下プレイヤー"}`;
      el.msg.textContent = m.otherPresent ? "相手が入室しました。「ゲーム開始」を押してください。" : "相手の入室待ち…";
      el.startBtn.disabled = !m.canStart;
      el.leaveBtn.disabled = false;
      if (typeof m.otherChar === "number"){ opChar=m.otherChar; updateThumbs(); }
      send({t:"char", c: myChar});
    }
    if (m.t==="other_char"){ opChar=m.c; updateThumbs(); }
    if (m.t==="info"){ el.msg.textContent = m.msg; }
    if (m.t==="start_ok"){ state.started=true; el.lobby.classList.add("hidden"); }
    if (m.t==="state"){ Object.assign(game, m.s); }
  }

  const pointers = new Map();
  let lastTap=0;
  function isDoubleTap(){ const now=performance.now(); const dt=now-lastTap; lastTap=now; return dt<300; }
  const toNormX = (clientX) => {
    const rect = canvas.getBoundingClientRect();
    return clamp((clientX - rect.left) / rect.width, 0, 1);
  };
  function sendPaddle(x){ if (state.inRoom) send({t:"input", x}); }
  function sendSpecial(){ if (state.inRoom) send({t:"special"}); }

  canvas.addEventListener("pointerdown",(e)=>{
    const rect = canvas.getBoundingClientRect();
    const y = (e.clientY - rect.top) / rect.height;
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId,true);

    const isTopHalf = (y < 0.5);
    if (state.role==="T" && !isTopHalf) return;
    if (state.role==="B" && isTopHalf) return;

    sendPaddle(toNormX(e.clientX));
    if (isDoubleTap()) sendSpecial();
    if (state.started && game.mode==="win") send({t:"rematch"});
  });
  canvas.addEventListener("pointermove",(e)=>{
    if (!pointers.has(e.pointerId)) return;
    const rect = canvas.getBoundingClientRect();
    const y = (e.clientY - rect.top) / rect.height;
    const isTopHalf = (y < 0.5);
    if (state.role==="T" && !isTopHalf) return;
    if (state.role==="B" && isTopHalf) return;
    sendPaddle(toNormX(e.clientX));
  });
  canvas.addEventListener("pointerup",(e)=>pointers.delete(e.pointerId));
  canvas.addEventListener("pointercancel",(e)=>pointers.delete(e.pointerId));

  function drawRacket(x, y, armed, side){
    const w=110,h=54;
    ctx.save();
    if(armed){
      ctx.globalAlpha=0.22;
      ctx.fillStyle = side==="T" ? "rgba(124,255,178,.95)" : "rgba(255,107,107,.95)";
      ctx.beginPath(); ctx.ellipse(x,y,w*0.62,h*0.62,0,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;
    ctx.fillStyle="rgba(255,255,255,.10)";
    ctx.beginPath(); ctx.ellipse(x,y,w*0.52,h*0.52,0,0,Math.PI*2); ctx.fill();
    ctx.lineWidth=3; ctx.strokeStyle="rgba(255,255,255,.24)";
    ctx.beginPath(); ctx.ellipse(x,y,w*0.52,h*0.52,0,0,Math.PI*2); ctx.stroke();
    const hw=18,hh=38;
    ctx.fillStyle="rgba(255,255,255,.08)";
    ctx.beginPath(); ctx.roundRect(x-hw/2,y+h*0.45,hw,hh,10); ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle="rgba(255,255,255,.16)"; ctx.stroke();
    ctx.restore();
  }
  function drawSprite(img,x,y,flip){
    if(!img.complete||img.naturalWidth===0) return;
    const targetH=82; const scale=targetH/img.naturalHeight; const tw=img.naturalWidth*scale;
    ctx.save(); ctx.translate(x,y); if(flip) ctx.scale(-1,1);
    ctx.globalAlpha=0.96; ctx.drawImage(img,-tw/2,-targetH/2,tw,targetH); ctx.restore();
  }
  function drawHUD(){
    const pad=10;
    ctx.save();
    ctx.globalAlpha=0.78; ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.beginPath(); ctx.roundRect(pad,pad,state.w-pad*2,58,14); ctx.fill();
    ctx.globalAlpha=0.95; ctx.fillStyle="#e8eef7";
    ctx.font="900 18px system-ui"; ctx.textAlign="center"; ctx.textBaseline="top";
    ctx.fillText(`${game.scoreT}  -  ${game.scoreB}`, state.w/2, pad+10);
    const gw=110,gh=8,y=pad+36;
    const leftX=state.w/2-gw-14,rightX=state.w/2+14;
    ctx.globalAlpha=0.35; ctx.fillStyle="#fff";
    ctx.fillRect(leftX,y,gw,gh); ctx.fillRect(rightX,y,gw,gh);
    ctx.globalAlpha=0.90;
    ctx.fillStyle="rgba(124,255,178,.95)"; ctx.fillRect(leftX,y,gw*game.gaugeT,gh);
    ctx.fillStyle="rgba(255,107,107,.95)"; ctx.fillRect(rightX,y,gw*game.gaugeB,gh);
    ctx.globalAlpha=0.72; ctx.fillStyle="#e8eef7";
    ctx.font="800 11px system-ui"; ctx.fillText(`自分の半分を操作／ダブルタップで必殺`, state.w/2, pad+52);
    ctx.restore();
  }
  function draw(){
    const w=state.w,h=state.h;
    const grad=ctx.createRadialGradient(w*0.5,h*0.25,40,w*0.5,h*0.25,Math.max(w,h));
    grad.addColorStop(0,"#14243a"); grad.addColorStop(0.62,"#0b0f14"); grad.addColorStop(1,"#070a0f");
    ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
    const margin=18;
    ctx.save(); ctx.globalAlpha=0.75; ctx.strokeStyle="rgba(255,255,255,.12)"; ctx.lineWidth=2;
    ctx.strokeRect(margin,margin,w-margin*2,h-margin*2); ctx.restore();
    ctx.save(); ctx.strokeStyle="rgba(255,255,255,.16)"; ctx.lineWidth=4;
    ctx.setLineDash([10,12]); ctx.beginPath(); ctx.moveTo(margin,h/2); ctx.lineTo(w-margin,h/2); ctx.stroke(); ctx.restore();

    const fieldW=w-margin*2, fieldH=h-margin*2;
    const pTx=margin+fieldW*game.paddleT;
    const pBx=margin+fieldW*game.paddleB;
    const pTy=margin+fieldH*0.08;
    const pBy=margin+fieldH*0.92;
    drawRacket(pTx,pTy,game.armedT,"T");
    drawRacket(pBx,pBy,game.armedB,"B");
    const safeYTop=margin+90, safeYBot=h-margin-90;
    const myIsTop = state.role==="T";
    drawSprite(myIsTop?sprites[myChar]:sprites[opChar], pTx, safeYTop, false);
    drawSprite(myIsTop?sprites[opChar]:sprites[myChar], pBx, safeYBot, false);

    const bx=margin+fieldW*game.ballX;
    const by=margin+fieldH*game.ballY;
    const br=Math.max(6,(w+h)*0.006*(game.ballR/0.012));
    ctx.save();
    ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fillStyle="#e8eef7"; ctx.fill();
    ctx.globalAlpha=0.25; ctx.beginPath(); ctx.arc(bx-2.5,by-3.2,br*0.6,0,Math.PI*2); ctx.fillStyle="#fff"; ctx.fill();
    ctx.restore();

    if (state.started) drawHUD();

    if (game.mode==="win" && game.winner){
      ctx.save();
      ctx.globalAlpha=0.9; ctx.fillStyle="rgba(0,0,0,.55)";
      ctx.beginPath(); ctx.roundRect(w*0.12,h*0.42,w*0.76,84,16); ctx.fill();
      ctx.fillStyle="#e8eef7"; ctx.font="900 20px system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(`WIN: ${game.winner==="T"?"上":"下"}（タップで再戦）`, w/2, h*0.42+42);
      ctx.restore();
    }
  }

  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  function loop(){ draw(); requestAnimationFrame(loop); }

  connect();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
